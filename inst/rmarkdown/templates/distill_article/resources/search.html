
<script type="application/javascript">

function getMeta(metaName) {
  var metas = document.getElementsByTagName('meta');
  for (let i = 0; i < metas.length; i++) {
    if (metas[i].getAttribute('name') === metaName) {
      return metas[i].getAttribute('content');
    }
  }
  return '';
}

function offsetURL(url) {
  var offset = getMeta('distill:offset');
  return offset ? offset + '/' + url : url;
}

function createIndex() {
  var options = {
    isCaseSensitive: false,
    shouldSort: true,
    keys: [
      "title",
      "description",
      "contents"
    ]
  };
  return new window.Fuse([],options);
}

function fetchArticles(fuse) {

  // fetch the main search.json
  return fetch(offsetURL('search.json'))
    .then(function(response) {
      if (response.status == 200) {
        return response.json().then(function(json) {
          // index main articles
          json.articles.forEach(function(article) {
            fuse.add(article);
          });
          // download collections and index their articles
          return Promise.all(json.collections.map(function(collection) {
            return fetch(offsetURL(collection)).then(function(response) {
              if (response.status === 200) {
                return response.json().then(function(articles) {
                  articles.forEach(function(article) {
                    fuse.add(article);
                  });
                })
              } else {
                console.log('Unexpected status from search index request: ' +
                  response.status);
              }
            });
          }));
        });

      } else {
        console.log('Unexpected status from search index request: ' +
                    response.status);
      }
    })
    .catch(function(error) {
       console.log('Error fetching search index');
       console.log(error);
    });

}

window.document.addEventListener("DOMContentLoaded", function (event) {

  // create fuse index and fetch articles
  var fuse = createIndex();
  fetchArticles(fuse);

  window.autocomplete('#distill-search', { hint: false }, [{
    source: function(query, callback) {
      var results = fuse.search(query, { limit: 10 });
      callback(results.map(function(result) { return result.item; }))
    },
    templates: {
      suggestion: function(suggestion) {
        return suggestion.title;
      }
    }
  }]).on('autocomplete:selected', function(event, suggestion, dataset, context) {
    window.location.href = offsetURL(suggestion.path);
  });

});

</script>

<style type="text/css">

/* Algolioa Autocomplete */

.algolia-autocomplete {
  display: inline-block;
  margin-left: 10px;
  vertical-align: sub;
  background-color: white;
  color: black;
  padding: 6px;
  padding-top: 8px;
  padding-bottom: 0;
  border-radius: 6px;
  border: 1px #455a64 solid;
  width: 200px;
}
.algolia-autocomplete .aa-input, .algolia-autocomplete .aa-hint {
  width: 90%;
  outline: none;
  border: none;
}

.algolia-autocomplete .aa-hint {
  color: #999;
}
.algolia-autocomplete .aa-dropdown-menu {
  width: 550px;
  overflow-x: visible;
  padding: 5px;
  margin-top: 3px;
  margin-left: -150px;
  background-color: #fff;
  border-radius: 5px;
  border: 1px solid #999;
  border-top: none;
}
.algolia-autocomplete .aa-dropdown-menu .aa-suggestion {
  cursor: pointer;
  padding: 5px 4px;
}
.algolia-autocomplete .aa-dropdown-menu .aa-suggestion.aa-cursor {
  background-color: #B2D7FF;
}
.algolia-autocomplete .aa-dropdown-menu .aa-suggestion em {
  font-weight: bold;
  font-style: normal;
}

</style>

